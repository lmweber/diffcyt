#' Test for differential abundance: method 'diffcyt-DA-censored-GLMM'
#' 
#' Calculate tests for differential abundance of cell populations using method
#' 'diffcyt-DA-censored-GLMM'
#' 
#' Calculates tests for differential abundance of clusters, using generalized linear mixed
#' models (GLMMs) where a covariate is subject to right censoring.
#' 
#' The same underlying testing as described in \code{\link{testDA_GLMM}} is 
#' applied here. The main difference is that multiple imputation is used to 
#' handle a censored covariate. In short, multiple imputation consists of three
#' steps: imputation, analysis and pooling. In the imputation step multiple complete
#' data sets are generated by imputation. The imputed data is then analysed in 
#' the second step and the results are combined in the third step. See also \code{\link[mice]{pool}}.
#' The imputation in the second step is specific for censored data in contrast to 
#' the 'normal' use of multiple imputation where data is missing (See Details). 
#' Alternativaly the samples with censored data can be removed (complete case analysis) 
#' or the censored values can be treated as missing (predictive mean matching) (See Details).
#' 
#' 
#' 
#' 
#' @param formula Model formula object, see \code{\link{testDA_GLMM}} and for more 
#'  details \code{\link{createFormula}}. Be aware of the special format required 
#'  for the censored covariate: instead of just the covariate name (e.g. 'X') the 
#'  columnname of the data being an event indicator (e.g. 'I', with 'I' = 1 if 
#'  'X' is observed and 'I' = 0 if 'X' is censored, ) needs to specified as well. 
#'  The notation in the formula is then 'Surv(X,I)'. 
#'  
#' @param mi_reps number of imputations in multiple imputation. default = 10.
#' 
#' @param imputation_method which method should be used in the imputation step. One of
#'  'km', 'rs', 'mrl', 'cc', 'pmm'. See details. default = 'km'.
#'  
#' @param BPPARAM specify parallelization option as one of 
#'  \code{\link[BiocParallel]{BiocParallelParam}} if 'BiocParallel' is available
#'  otherwise no parallelization.
#'  e.g. \code{\link[BiocParallel]{MulticoreParam}}(workers=2) for parallelization 
#'  with two cores. Default is \code{\link[BiocParallel]{SerialParam}}()
#'  (no parallelization). 
#'  
#' @param verbose Logical.
#' 
#' @inheritParams testDA_GLMM 
#' 
#' @inherit testDA_GLMM return
#' 
#' @details Possible methods in 'imputation_method' are:
#' \describe{
#'   \item{'km'}{Kaplan Meier imputation is similar to 'rs' (Risk set imputation) 
#'               but the random draw is according to the survival function of
#'               the respective risk set.}
#'   \item{'rs'}{Risk Set imputation replaces the censored values with a random
#'               draw from the risk set of the respective censored value.}
#'   \item{'mrl'}{Mean Residual Life (Conditional single imputation from 
#'                \href{https://www.researchgate.net/publication/319246304_Improved_conditional_imputation_for_linear_regression_with_a_randomly_censored_predictor}{Atem et al. 2017})
#'                is a multiple imputation procedure that bootstraps the data and
#'                imputes the censored values by replacing them with their 
#'                respective mean residual life.}
#'   \item{'cc'}{complete case (listwise deletion) analysis removes incomlete samples.}
#'   \item{'pmm'}{predictive mean matching treats censored values as missing and
#'                uses predictive mean matching method from \code{\link[mice]{mice}}.}
#' }
#'
#' @export
#' @examples 
#' # formula for dependency in the data
#' data_formula <- formula(counts ~ Surv(survival_time, event_indicator) + group_id + (1 | sample_id))
#' 
#' # create small data set with 4 clusters with 10 samples.
#' d_counts <- simulate_data(
#'  n = 10,
#'  formula = data_formula,
#'  n_levels_fixeff = 2,
#'  type = "glmer",
#'  b = list(b=c(-5,-2,0.2)),
#'  number_of_clusters = 4,
#'  number_of_differential_clusters = 1)
#'
#' # extract covariates data.frame
#' experiment_info <- SummarizedExperiment::colData(d_counts)
#' 
#' # create model formula object
#' da_formula <- createFormula(experiment_info, 
#'                             cols_fixed = c("survival_time", "group_id"),
#'                             cols_random = "sample_id", 
#'                             event_indicator = "event_indicator")
#' 
#' # create contrast matrix
#' contrast <- createContrast(c(0, 1, 0))
#'
#' # run testing with imputation method 'km' 
#' outs <- testDA_censoredGLMM(d_counts = d_counts, formula = da_formula,
#'                            contrast = contrast, mi_reps = 2, imputation_method = "km")
#'
testDA_censoredGLMM <- function(d_counts, formula, contrast, mi_reps = 10,
                                imputation_method = c("km","rs","mrl","cc","pmm"),
                                min_cells = 3,
                                min_samples = NULL,
                                normalize = FALSE, 
                                norm_factors = "TMM",
                                BPPARAM=BiocParallel::SerialParam(),
                                verbose = FALSE
                                )
{
  if (is.null(min_samples)) {
    min_samples <- ncol(d_counts) / 2
  }
  
  imputation_method <- match.arg(imputation_method)
  BPPARAM <- if(requireNamespace("BiocParallel")){BPPARAM} else{NULL}
  # variable names from the given formula
  cmi_input <- extract_variables_from_formula(formula$formula)
  
  if (!is.numeric(formula$data[[cmi_input$censored_variable]])){
    stop(paste0("The censored variable '",cmi_input$censored_variable, "' is not numeric."), call. = FALSE)
  }
  
  # create formula for fitting
  formula_glmm <- create_glmm_formula(formula$formula)
  
  counts <- SummarizedExperiment::assays(d_counts)[["counts"]]
  cluster_id <- SummarizedExperiment::rowData(d_counts)$cluster_id
  # only keep counts with more than the minimum number of cells
  counts_to_keep <- counts >= min_cells
  
  # only keep clusters with more than the minimum number of samples
  rows_to_keep <- apply(counts_to_keep, 1, function(r) sum(r) >= min_samples)
  
  # subset counts and cluster_id's
  counts <- counts[rows_to_keep, , drop = FALSE]
  cluster_id <- cluster_id[rows_to_keep]

    # normalization factors
  if (normalize & norm_factors == "TMM") {
    norm_factors <- calcNormFactors(counts, method = "TMM")
  }
  
  if (normalize) {
    weights <- colSums(counts) / norm_factors
  } else {
    weights <- colSums(counts)
  }
  
  if (ncol(contrast) == 1 & nrow(contrast) > 1) {
    contrast <- t(contrast)
  }
  
  if (sum(contrast) != 1 | any(!(contrast %in% c(0,1)))){
    stop("General Linear Hypotheses testing is currently not supported in 
         'testDA_GLMM', make sure to only have one '1' in 'contrast'.", call. = FALSE)
  }

  if (verbose) message(paste(sum(formula$data[[cmi_input[["censoring_indicator"]]]] == 0),
                           "of", dim(formula$data)[1], "values are censored"))
  # start fitting by iterating through the clusters, use normal lapply if 
  # 'BiocParallel' isn't install otherwise use bplapply
  p_vals_ls <- maybe_parallel_lapply(seq_along(cluster_id), 
                                     BPPARAM=BPPARAM,
                                     function(i) {
    # data preparation
    y <- counts[i, ]/weights
    data_i <- cbind(y, weights, formula$data)
    colnames(data_i)[c(1,2)] <- c(cmi_input$response,"weights")
    
    # do conditional multiple imputation
    if (imputation_method %in% c("mrl","rs","km","pmm")){
      out_test <- tryCatch(suppressMessages(suppressWarnings(
        conditional_multiple_imputation(
          data = data_i,
          formula = formula$formula,
          mi_reps = mi_reps,
          imputation_method = imputation_method,
          regression_type = "glmer",
          family = "binomial",
          verbose = verbose,
          weights = "weights",
          contrasts = contrast
        ))),
      error=function(e) NA)
      # pooling of results from multiple imputation
      p_val <- tryCatch(summary(mice::pool(out_test$fits))$p.value[ which(contrast == 1)],
                        error=function(e) NA)
    } # complete case fitting and testing
    else if (imputation_method == "cc"){
      p_val <- tryCatch({
      fit <- suppressMessages(suppressWarnings(complete_case(
        data = data_i,censored_variable = cmi_input[["censored_variable"]],
        censoring_indicator = cmi_input[["censoring_indicator"]],
        formula = formula_glmm,regression_type = "glmer",
        weights = "weights",family = "binomial")$fits))
      test <- multcomp::glht(fit, contrast)
      summary(test)$test$pvalues
      },error=function(e) NA)
    }
    return(p_val)
  })
  p_vals <- unlist(p_vals_ls)
  # fdr correction
  p_adj <- p.adjust(p_vals, method = "fdr")
  stopifnot(length(p_vals) == length(p_adj))
  
  row_data <- data.frame(cluster_id = as.character(cluster_id),
                         p_val = p_vals,
                         p_adj = p_adj,
                         stringsAsFactors = FALSE)
  # return NA if cluster has been excluded from testing because of too few observations
  row_data <- suppressMessages(suppressWarnings(
    dplyr::right_join(row_data,
                      data.frame(SummarizedExperiment::rowData(d_counts)))))
  
  res <- SummarizedExperiment::SummarizedExperiment(
    assays = list(counts = SummarizedExperiment::assay(d_counts)),
    rowData = row_data,
    colData = SummarizedExperiment::colData(d_counts))
  
  # return normalization factors in 'metadata'
  if (normalize) {
    metadata(res)$norm_factors <- norm_factors
  }
  return(res)
}

# if namespace 'BiocParallel' is available run 'BiocParallel::bplapply', otherwise
# run lapply
maybe_parallel_lapply <- function(X, FUN, BPPARAM) {
  if (requireNamespace("BiocParallel", quietly = TRUE)) {
    BiocParallel::bplapply(X, FUN, BPPARAM=BPPARAM)
  } else {
    lapply(X, FUN)
  }
}