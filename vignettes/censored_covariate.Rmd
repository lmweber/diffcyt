---
title: "Censored covariate workflow"
author:
  - name: Reto Gerber
    affiliation: 
      - &id1 "Institute of Molecular Life Sciences, University of Zurich, Zurich, Switzerland"
      - &id2 "SIB Swiss Institute of Bioinformatics, University of Zurich, Zurich, Switzerland"
package: diffcyt
output:
  BiocStyle::html_document
abstract: |
  This vignette shows an example of how to perform differential abundance (DA) analysis with a covariate subject to right censoring (e.g. survival time) in the `diffcyt` package.
vignette: |
  %\VignetteIndexEntry{Censored covariate diffcyt workflow}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: references.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# Introduction

This vignette shows an example of how to perform differential abundance (DA) analysis with a covariate subject to right censoring (e.g. survival time) in the `diffcyt` package. Before going through this vignette it is advisable to have a look at the [diffcyt workflow vignette](http://bioconductor.org/packages/release/bioc/vignettes/diffcyt/inst/doc/diffcyt_workflow.html) which considers the 'normal' (fully observed) case.

If a time-to-event variable (e.g. survival time) connected to a cytometry sample is available, one might be interested in the association between the cell population abundance and this time-to-event variable. In practice, a frequent problem with time-to-even variables is that not all events are observed. Instead it could be that only a minimum time is known, with other words those values are (right) censored. If standard analysis would be used (such as `testDA_GLMM` or `testDA_edgeR`) a bias is introduced in the parameter estimation. The simplest workaround is to exclude all incomplete samples, which is known under the name of complete case analysis or listwise deletion. But there are cases where this approach is not advisable, since it can greatly reduce statistical power (when the censoring rate is high) and might intoduces a bias (when censoring is not random).

<!-- Want to do DA analysis to find cell populations whose abundance is associated with survival time (or in general a time-to-event variable). -->

Normally, when a variable is censored, association testing can be done using classical survival analysis methods (e.g. Cox proportional hazard model). But in the context of differential abundance analysis in `diffcyt` the censored variable is not the response but a covariate (in contrary to classical survival analyis). The approach used to overcome this hurdle is multiple imputation [@Rubin1988] which allows the use of the standard differential analysis methods at the cost of increased computational cost. Multiple imputation consists of the three steps `Imputation`, `Analysis` and `Pooling`.

In the first step (`Imputation`) multiple complete data sets are generated by replacing the missing (or censored) values by a random draw from a predictive distribution (See \@ref(tab:methods)).
Then in the second step (`Analysis`) a GLMM is fitted on each imputated datasets.
In the last step (`Pooling`) the results from the second step are combined using Rubins's rules which take into account the additional variance from the imputation.

In the main function `testDA_censoredGLMM` there are three main imputation methods available:

Method | Description| Abbr. 
-------|------------------------|--
Complete case analysis | Incomplete samples are removed. | cc
 Risk set imputation [@Taylor2002] | The censored values are replace by a random value from its risk set.| rs
Kaplan-Meier imputation [@Taylor2002] |  A censored value is replaced by a random draw from a survival function that has been fit on the risk set of the respective censored value.| km 
Mean residual life imputation [@Atem2017]|  Bootstrapping of the incomplete data and replacement of the censored values by adding the mean residual life (the expected time until event given the censoring time).| mrl 

: (\#tab:methods) Description of imputation methods.

If the largest value is censored the survival function does not reach its theoretical minimum of 0 which would leave some replacements undefined. Multiple options to handle this problem are implemented for use in Kaplan-Meier imputation:

Description |  Abbr. 
------------------------|--
Set the largest value as observed. (default) | km 
Model tail of the survival function as an exponential distribution. [@Moeschberger1985] | km_exp 
Model tail of the survival function as a weibull distribution. [@Moeschberger1985] | km_wei 
Replace all censored values larger than the largest observed value with expected values according to order statistics. [@Moeschberger1985] | km_os 

: (\#tab:tailmethods) Description of survival function tail approximation.



# Data set
First load the necessary packages
```{r load packages}
suppressPackageStartupMessages({
  library(diffcyt)
  library(ggplot2)
  library(SummarizedExperiment)
  library(tidyr)
})
```

The main input for DA analysis consists of a matrix of counts representing the number of cells in a cluster (cell population) in a sample. How to obtain those counts is explained in the [main vignette](http://bioconductor.org/packages/release/bioc/vignettes/diffcyt/inst/doc/diffcyt_workflow.html) and will not be further considered here, instead for purely illustrative purposes a dataset is simulated. The simulation function `simulate_multicluster` models the data according to a dirichlet-multinomial distribution where some clusters have an association with a covariate.

```{r data_simulation}
set.seed(1234)

nr_samples <- 50
nr_clusters <- 4
# number of cell per sample
sizes <- round(runif(nr_samples,1e3,1e4))
# alpha parameters of the dirichlet-multinomial distribution. 
alphas <- runif(nr_clusters,1,10)

# the covariate is simulated from an exponential distribution:
X <- rexp(nr_samples)
# the censoring time is also sampled from an exponential distribution:
C <- rexp(nr_samples)
# the actual observed value is the minimum of the two:
T <- pmin(X,C)
# additionally, we have the event indicator:
I <- ifelse(X>C,0,1)
# proportion censored:
(length(I)-sum(I))/length(I)

# main simulation function
simulation_output <- simulate_multicluster(alphas = alphas,
                                           sizes = sizes,
                                           covariate = X,
                                           nr_diff = 2,
                                           return_summarized_experiment = TRUE,
                                           slope = list(0.9))
# counts as a SummarizedExperiment object
d_counts <- simulation_output$counts
```

Let's have a short look at the simulated data and plot association of covariate vs. proportion
```{r diffplot, fig.cap="Cell population proportion vs. survival time (T). I is the indicator function with I=0: censored and I=1: observed.", fig.wide=TRUE}

# vector indicating if a cluster has a modeled association or not
is_diff_cluster <- ifelse(is.na(simulation_output$row_data$paired),FALSE,TRUE)
# first convert to proportions:
proportion <- as.data.frame(t(apply(assay(d_counts),2,function(x)x/sum(x))))
names(proportion) <- paste0("Nr: ",names(proportion), " - ", ifelse(is_diff_cluster,"DA","non DA"))
# then to long format for plotting
counts_long <-
  pivot_longer(proportion, cols= seq_len(nr_clusters),names_to = "cluster_id",values_to = "proportion")
# add association
counts_long$is_diff_cluster <- rep(is_diff_cluster,nr_samples)
# add observed (partly censored) variable
counts_long$T <- rep(T,each=nr_clusters)
# add event indicator
counts_long$I <- as.factor(rep(I,each=nr_clusters))

ggplot(counts_long) +
  geom_point(aes(x=T,y=proportion,color=I)) +
  facet_wrap(~cluster_id)
```



# Set up meta-data

Next we need to set up the meta data, i.e. the covariates that are used in the testing.

```{r experiment_info}
# all covariates and sample ids
experiment_info <- data.frame(ID = seq_len(nr_samples), T = T, I = I)
```

Variables that are right censored are represented by two vectors, one is the measured values and the second indicates if the measured values are observed (1) or censored (0). The `createFormula` function is the same as used in the normal `diffcyt` workflow but additionally the argument `event_indicator` has to be specified by giving the respective column name in `experiment_info`. If multiple covariates are given in argument `cols_fixed` then `event_indicator` is associated with the first element given to `cols_fixed`.
```{r formula_contrast}
da_formula <- createFormula(experiment_info = experiment_info,
                            cols_fixed = "T",
                            cols_random = "ID",
                            event_indicator = "I")
# also create contrast matrix for testing
contrast <- matrix(c(0,1))
```


# Differential testing
The main part is the differential testing which is analog to the normal workflow and is done using the function `testDA_censoredGLMM`. It consists of the same argument as the non-censored version `testDA_GLMM` with two additional arguments specific to the multiple imputation. The first additional argument is `mi_reps` (multiple imputation repetitions) which is the number of multiple imputation steps performed. Unfortunately there is no clear rule as to how many imputations are needed and only rules of thumb are availabe [@VanBuuren2018]. In general, more imputations are needed if the censoring rate is high and in applications where a high statistical power is needed [@VanBuuren2018]. One 'rule' is the quadratic rule of @VonHippel2018 which can be shown if `verbose` is set to  `TRUE`. 
The second argument is `imputation_method` to specify which imputation method should be used. See Table \@ref(tab:methods) and Table \@ref(tab:tailmethods) for possible values.
```{r differential_testing, message=TRUE}
# test with 50 repetitions with method risk set imputation (rs)
da_out <- testDA_censoredGLMM(d_counts = d_counts,
                              formula = da_formula,
                              contrast = contrast,
                              mi_reps = 50,
                              imputation_method = "rs",
                              verbose = TRUE)
topTable(da_out)

# compare to actual differential clusters:
which(!is.na(simulation_output$row_data$paired))
```


# Session info {.unnumbered}

```{r sessionInfo, echo=FALSE}
sessionInfo()
```
# References
